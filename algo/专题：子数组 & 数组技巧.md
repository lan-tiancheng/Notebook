# ä¸“é¢˜ï¼šå­æ•°ç»„ & æ•°ç»„æŠ€å·§ï¼ˆGo è¯­è¨€å‘ï¼‰

é¡ºå¸¦æé†’ä¸€å¥ï¼š**Go é‡Œæ²¡æœ‰ whileï¼Œfor æ˜¯ä¸‡èƒ½å½¢æ€ã€‚**

------

## å‰ç¼€å’Œï¼ˆPrefix Sumï¼‰

### æ ¸å¿ƒæ€æƒ³

æŠŠâ€œåŒºé—´é—®é¢˜â€è½¬åŒ–ä¸ºâ€œä¸¤ä¸ªç‚¹çš„é—®é¢˜â€ã€‚

å®šä¹‰ï¼š

- `pre[i]` è¡¨ç¤ºåŒºé—´ `[0..i]` çš„å…ƒç´ å’Œ

é€’æ¨å…³ç³»ï¼š

```
pre[i] = pre[i-1] + nums[i]
```

é‚£ä¹ˆä»»æ„å­æ•°ç»„ `[j..i]` çš„å’Œä¸ºï¼š

```
sum(j..i) = pre[i] - pre[j-1]
```

å¦‚æœé¢˜ç›®å‡ºç°ï¼š

> å­æ•°ç»„å’Œ = k

ç«‹åˆ»ç¿»è¯‘æˆï¼š

```
pre[i] - pre[j-1] = k
=> pre[j-1] = pre[i] - k
```

é—®é¢˜å°±å˜æˆï¼š
**åœ¨ i ä¹‹å‰ï¼Œæœ‰å¤šå°‘ä¸ªå‰ç¼€å’Œç­‰äº `pre[i]-k`ï¼Ÿ**

è¿™å°±æ˜¯ `map[å‰ç¼€å’Œ] = å‡ºç°æ¬¡æ•°` çš„ç”¨æ­¦ä¹‹åœ°ã€‚

------

## å­æ•°ç»„å’Œä¸º k çš„ä¸ªæ•°

### é¢˜ç›®æ¨¡å‹è¯†åˆ«

- è¿ç»­
- æ±‚åŒºé—´å’Œ
- ç»Ÿè®¡â€œä¸ªæ•°â€

ğŸ‘‰ **å‰ç¼€å’Œ + å“ˆå¸Œè¡¨ï¼ˆç»å…¸ç»„åˆï¼‰**

### æ­£ç¡®ä¸”ä¸æ˜“é”™çš„ Go å®ç°

```go
func subarraySum(nums []int, k int) int {
    cnt, pre := 0, 0
    m := make(map[int]int)
    m[0] = 1 // è¡¨ç¤ºâ€œä»€ä¹ˆéƒ½ä¸é€‰â€çš„å‰ç¼€

    for _, x := range nums {
        pre += x
        if c, ok := m[pre-k]; ok {
            cnt += c
        }
        m[pre]++
    }
    return cnt
}
```

### æ˜“é”™ç‚¹é€Ÿè®°

- `m[0] = 1` å¿…é¡»æœ‰ï¼šè¡¨ç¤ºä»ä¸‹æ ‡ 0 å¼€å§‹çš„å­æ•°ç»„
- å…ˆæŸ¥ `pre-k`ï¼Œå†æ›´æ–° `m[pre]`
- ä¸éœ€è¦çœŸçš„å¼€ `prefix` æ•°ç»„ï¼Œ**è¾¹èµ°è¾¹ç®—**å³å¯

------

## æœ€å¤§å­æ•°ç»„å’Œï¼ˆMaximum Subarrayï¼‰

è¿™æ˜¯â€œå­æ•°ç»„â€é‡Œæœ€æœ‰å“²å­¦å‘³çš„ä¸€é¢˜ã€‚

### è§£æ³•ä¸€ï¼šå‰ç¼€å’Œ + æœ€å°å‰ç¼€

æ•°å­¦è§†è§’ï¼š

```
max(sum[j..i]) = max(pre[i] - min(pre[j]))  (j < i)
import "math"

func maxSubArray(nums []int) int {
    sum := 0
    minPre := 0
    ans := math.MinInt

    for _, x := range nums {
        sum += x
        ans = max(ans, sum-minPre)
        minPre = min(minPre, sum)
    }
    return ans
}
```

è¿™å·²ç»æ˜¯ **DP æ€æƒ³** äº†ï¼Œåªæ˜¯æŠ«ç€å‰ç¼€å’Œçš„å¤–è¡£ã€‚

------

### è§£æ³•äºŒï¼šKadane ç®—æ³•ï¼ˆæœ€æ¨èï¼‰

è¿™æ˜¯**çœŸæ­£è¯¥èƒŒä¸‹æ¥çš„ç‰ˆæœ¬**ã€‚

#### æ€ç»´æ¨¡å‹ï¼ˆéå¸¸é‡è¦ï¼‰

- `cur`ï¼š
  ä»¥å½“å‰ä½ç½®ç»“å°¾çš„**æœ€å¤§å­æ•°ç»„å’Œ**
- `ans`ï¼š
  å†å²å…¨å±€æœ€å¤§å€¼

æ¯ä¸€æ­¥éƒ½åœ¨é—®ä¸€å¥äººè¯ï¼š

> æˆ‘æ˜¯ç»§ç»­èƒŒç€ä¹‹å‰çš„åŒ…è¢±ï¼Œè¿˜æ˜¯ä»è¿™é‡Œé‡æ–°åšäººï¼Ÿ

```go
func maxSubArray(nums []int) int {
    cur, ans := nums[0], nums[0]

    for i := 1; i < len(nums); i++ {
        cur = max(nums[i], cur+nums[i])
        ans = max(ans, cur)
    }
    return ans
}
```

### ä¸€å¥è¯æ€»ç»“

> Kadane = **å±€éƒ¨æœ€ä¼˜ + å…¨å±€è®°å½•**

æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´ O(1)ï¼Œé¢è¯•å®˜æœ€çˆ±ã€‚

------

## åˆå¹¶åŒºé—´

### é¢˜ç›®è¯†åˆ«ä¿¡å·

- ç»™çš„æ˜¯ä¸€å † `[start, end]`
- è¦â€œåˆå¹¶é‡å â€

ğŸ‘‰ **æ’åº + æ‰«æ**

### æ ¸å¿ƒæ­¥éª¤

1. æŒ‰ `start` å‡åºæ’åº
2. ç»´æŠ¤ç»“æœæ•°ç»„çš„â€œæœ€åä¸€ä¸ªåŒºé—´â€
3. èƒ½åˆå°±æ‰©å±•ï¼Œä¸èƒ½åˆå°±æ–°å¼€

```go
import "slices"

func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return intervals
    }

    slices.SortFunc(intervals, func(a, b []int) int {
        return a[0] - b[0]
    })

    res := [][]int{intervals[0]}

    for _, cur := range intervals[1:] {
        last := res[len(res)-1]
        if cur[0] > last[1] {
            res = append(res, cur)
        } else if cur[1] > last[1] {
            last[1] = cur[1]
        }
    }
    return res
}
```

### æ³¨æ„

- `[1,4]` å’Œ `[4,5]` **ç®—é‡å **
- äºŒç»´æ•°ç»„ `len(intervals)` è¿”å›çš„æ˜¯â€œåŒºé—´ä¸ªæ•°â€

------

## è½®è½¬æ•°ç»„

### æ–¹æ³•ä¸€ï¼šé¢å¤–æ•°ç»„ï¼ˆç›´è§‚ç‰ˆï¼‰

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n
    tmp := make([]int, n)

    for i, v := range nums {
        tmp[(i+k)%n] = v
    }
    copy(nums, tmp)
}
```

ç©ºé—´ O(n)ï¼Œæ€è·¯æœ€æ¸…æ™°ã€‚

------

### æ–¹æ³•äºŒï¼šä¸‰æ¬¡ç¿»è½¬ï¼ˆå¿…ä¼šï¼‰

é€»è¾‘é¡ºåºï¼š

1. æ•´ä½“ç¿»è½¬
2. ç¿»è½¬å‰ k ä¸ª
3. ç¿»è½¬å n-k ä¸ª

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n

    reverse(nums, 0, n-1)
    reverse(nums, 0, k-1)
    reverse(nums, k, n-1)
}

func reverse(nums []int, l, r int) {
    for l < r {
        nums[l], nums[r] = nums[r], nums[l]
        l++
        r--
    }
}
```

æ—¶é—´ O(n)ï¼Œç©ºé—´ O(1)ï¼Œç»å…¸æ¨¡æ¿ã€‚

------

## é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯

### é¢˜ç›®é™åˆ¶ä¿¡å·

- ä¸èƒ½ç”¨é™¤æ³•
- O(n)

ğŸ‘‰ **å‰ç¼€ç§¯ + åç¼€ç§¯**

------

### æ–¹æ³•ä¸€ï¼šå·¦å³æ•°ç»„ï¼ˆæ˜“ç†è§£ï¼‰

```go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    left := make([]int, n)
    right := make([]int, n)

    left[0] = 1
    for i := 1; i < n; i++ {
        left[i] = left[i-1] * nums[i-1]
    }

    right[n-1] = 1
    for i := n - 2; i >= 0; i-- {
        right[i] = right[i+1] * nums[i+1]
    }

    ans := make([]int, n)
    for i := 0; i < n; i++ {
        ans[i] = left[i] * right[i]
    }
    return ans
}
```

------

### æ–¹æ³•äºŒï¼šç©ºé—´ O(1)ï¼ˆé¢è¯•åŠ åˆ†ï¼‰

```go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)

    ans[0] = 1
    for i := 1; i < n; i++ {
        ans[i] = ans[i-1] * nums[i-1]
    }

    tmp := 1
    for i := n - 2; i >= 0; i-- {
        tmp *= nums[i+1]
        ans[i] *= tmp
    }
    return ans
}
```

æœ¬è´¨ï¼š

> æŠŠ left å’Œ right çš„å·¥ä½œéƒ½â€œå‹ç¼©â€è¿› ans é‡Œã€‚

------

## æœ€åä¸€å¥æ€»çº²

- å­æ•°ç»„ â‰ˆ **å‰ç¼€æ€æƒ³**
- æœ€å¤§å’Œ â‰ˆ **Kadane**
- åŒºé—´é—®é¢˜ â‰ˆ **æ’åº + æ‰«æ**
- åŸåœ°æ“ä½œ â‰ˆ **åè½¬ / æ»šåŠ¨å˜é‡**

åˆ·é¢˜ä¸æ˜¯è®°ä»£ç ï¼Œæ˜¯è®°**æ¨¡å‹**ã€‚
æ¨¡å‹ä¸€æ—¦å¯¹äº†ï¼Œä»£ç åªæ˜¯ç¿»è¯‘ã€‚
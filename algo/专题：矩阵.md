# 专题：矩阵

## 矩阵置零

### 方法一

利用两个标记数组，看这一行/列是否有0存在，之后再利用这两个标记数组来更新原数组的值。

```go
func setZeroes(matrix [][]int) {
	row := make([]bool, len(matrix))
	col := make([]bool, len(matrix[0]))

	for i, r := range matrix {
		for j, v := range r {
			if v == 0 {
				row[i] = true
				col[j] = true
			}
		}
	}

	// 更新

	for i, r := range matrix {
		for j, _ := range r {
			if row[i] || col[j] {
				r[j] = 0
			}
		}
	}
}
```

空间复杂度O(m+n) 时间复杂度 O（mn）

### 方法二

原地算法，利用第一行第一列来充当标记，空间复杂度为O(1)

```go
func setZeroes(matrix [][]int)  {
    // 利用第一行和第一列作为是否有0的指示 
    // 首先判断第一行/列是否有0 
    row_0 := false 
    col_0 := false 

    for _, v := range matrix[0]{
        if v == 0 {
            row_0 = true 
            break
        }
    }

    for _,v :=range matrix{
        if v[0] == 0 {
            col_0 = true 
            break
        }
    }

    // 标记
    for i := 1;i<len(matrix);i++{
        for j:=1;j<len(matrix[0]);j++{
            if matrix[i][j] == 0 {
                matrix[0][j] = 0 
                matrix[i][0] = 0 
            }
        }
    }

    // 修改
    for i:=1;i<len(matrix);i++{
        for j:= 1;j<len(matrix[0]);j++{
            if matrix[i][0]==0||matrix[0][j]==0{
                matrix[i][j] = 0 
            }
        }
    }

    // 如果第一行第一列有0，那么就把第一列和第一行置为0 
    if row_0 {
        for j:=0;j<len(matrix[0]);j++{
            matrix[0][j] = 0 
        }
    }

    if col_0 {
        for i:=0;i<len(matrix);i++{
            matrix[i][0] = 0 
        }
    }

}
```

## 螺旋数组

1. 方法一：模拟法

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix)==0||len(matrix[0])==0 {
        return []int{}
    }

    rows := len(matrix)
    columns := len(matrix[0])

    // 创建一个相同大小的数组来记录元素是否被访问过
    visited := make([][]bool, rows)
    for i:= 0;i<rows;i++{
        visited[i] = make([]bool,columns)
    }

    // 定义变量
    var (
        total = rows * columns
        // 输出结果
        order = make([]int,total)
        row, col = 0,0
        // 方向矩阵
        directions = [][]int{[]int{0,1},[]int{1,0},[]int{0,-1},[]int{-1,0}}
        directionIndex = 0 
    )
    for i:=0;i<total;i++{
        order[i] = matrix[row][col]
        visited[row][col] = true 
        // 判断是否有越界的情况
        nextRow := row + directions[directionIndex][0]
        nextCol := col + directions[directionIndex][1]
        if nextRow<0||nextRow>=rows||nextCol<0||nextCol>=columns||visited[nextRow][nextCol]==true{
            directionIndex = (directionIndex+1)%4
        }
        row = row + directions[directionIndex][0]
        col = col + directions[directionIndex][1]
    }
    return order
}
```

2. 方法二 逐层展开

```go
func spiralOrder(matrix [][]int) []int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return []int{}
	}
	rows := len(matrix)
	columns := len(matrix[0])
    total := rows*columns

	top, bottom, left, right := 0, rows-1, 0, columns-1

    order := []int{}

    for len(order)<total{
        // 右
        for i:=left;i<=right;i++{
            if len(order)>total {
                return order 
            }
            order = append(order, matrix[top][i])
        }
        top++
        // 下
        for i:=top;i<=bottom;i++{
            if len(order)>=total {
                return order 
            }
            order = append(order,matrix[i][right])
        }
        right--
        // 左 
        for i:= right;i>=left;i--{
            if len(order)>=total{
                return order
            }
            order = append(order,matrix[bottom][i])
        }
        bottom--
        // 上
        for i:=bottom;i>=top;i--{
            if len(order)>=total {
                return order
            }
            order = append(order,matrix[i][left])
        }
        left++
    }
    return order 

    return order 

}
```

## 旋转图像

1. 方法一 : 原地旋转

```go
func rotate(matrix [][]int) {
	// n*n的矩阵 顺时针旋转90度
	n := len(matrix)

	for j := 0; j < n/2; j++ {
		for i := j; i < n-1-j; i++ {
			// 移动四个数字[j,i] [i,n-1-j],[n-1-j,n-1-i],[n-1-i,j]
			matrix[j][i], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[j][i]
			matrix[j][i], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[j][i]
			matrix[j][i], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[j][i]
		}
	}
}
```

2. 方法二 ：使用额外的空间

```go
func rotate(matrix [][]int)  {
    // 创建一个额外的空间来存储
    n := len(matrix)
    ans := make([][]int,n)
    for i:=0;i<n;i++{
        ans[i] = make([]int , n)
    }
    for i:=0;i<n;i++{
        for j:=0;j<n;j++{
            ans[j][n-1-i] = matrix[i][j]
        }
    }
    copy(matrix,ans)
}
```

3. 方法三：利用翻转变换代替旋转

首先进行上下翻转，接下来进行对角线翻转。

```go
func rotate(matrix [][]int)  {
    // 首先进行上下翻转
    n := len(matrix)
    for i := 0; i<n/2 ;i++{
        matrix[i], matrix[n-i-1] = matrix[n-1-i],matrix[i]
    }

    // 接下来进行对角线变换
    for i:=0;i<n-1;i++{
        for j := i+1 ;j <n ;j++{
            matrix[i][j] , matrix[j][i] = matrix[j][i] , matrix[i][j]
        }
    }
}
```

## 搜索二维数组

1. 方法一：直接遍历
2. 方法二：二分查找

直接对每一行进行二分查找，时间复杂度O(mlogn)，注意二分查找的写法。

```go
func searchMatrix(matrix [][]int, target int) bool {
	// 对每一行的数据进行一次二分查找
	for _, row := range matrix {
		if binarysearch(row, target) {
			return true
		}
	}
	return false
}

func binarysearch(arr []int, target int) bool {
	// 二分查找自实现
	n := len(arr)
	left, right := 0, n-1
	for left <= right { // 有等号，保证覆盖最后一个元素
		mid := left + (right-left)/2
		if arr[mid] == target {
			return true
		} else if arr[mid] > target {
			right = mid - 1
		} else {
			left = mid + 1 // 保证不会死循环
		}
	}
	return false
}
```

3. Z型查找

右上角的元素的性质：左侧的数都比他小，下面的数都比他大，天然的分界点

````go
func searchMatrix(matrix [][]int, target int) bool {
	// m*n的矩阵
	rows := len(matrix)
	columns := len(matrix[0])

	x, y := 0, columns-1

	for x < rows && y >= 0 {
		if matrix[x][y] == target {
			return true
		}
		if matrix[x][y] < target {
			x++
		} else {
			y--
		}// 注意这里的写法
	}
	return false
}
````


# 专题 ： 滑动窗口

## 什么是滑动窗口？

其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

时间复杂度：O(n)

## C++ 语法补充

unordered_set，是cpp中的集合数据结构，所有元素只能出现一次 
声明方法

```c++
// unordered_set<type> set_name;
unordered_set<char> lookup;
```

常用方法

``` c++
lookup.insert('a');// 插入方法
lookup.find('a');// 查找方法，如果有返回元素的位置，没有，返回lookup.end()
// 判断元素是否存在 if(lookup.find('a')==lookup.end())
lookup.erase('a');// 删除方法
```

## 模板

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;
        unordered_set<char> lookup;
        int maxStr = 0;
        int left = 0;
        for(int i = 0; i < s.size(); i++){
            while (lookup.find(s[i]) != lookup.end()){
                lookup.erase(s[left]);
                left ++;
            }
            maxStr = max(maxStr,i-left+1);
            lookup.insert(s[i]);
    }
        return maxStr;
        
    }
};
// 利用unordered_set,存储当前窗口中所含有的元素
```

## 例题 

### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

C++ 

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        if (n == 0) return 0;
        unordered_set<char> lookup ;
        int left = 0;
        int max_len = 0 ;
        for (int i = 0 ;i<n;i++){
            while (lookup.find(s[i])!=lookup.end())
            {
                // 也就是说此时出现了重复，那么我就要把左侧删除，直到没有重复
                lookup.erase(s[left]);
                left++;
            }
            max_len = max (max_len , i - left +1);
            lookup.insert(s[i]);
        }
        return max_len;
    }
};
```

模板真好用
